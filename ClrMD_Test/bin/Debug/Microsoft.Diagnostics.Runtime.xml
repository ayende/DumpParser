<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Runtime</name>
    </assembly>
    <members>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SOURCE_PATH_HAS_SOURCE_SERVER">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_CONTEXT">
            <summary>
            InBuffer - Unused.
            OutBuffer - Machine-specific CONTEXT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_THREAD">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG system ID of thread.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_RECORD">
            <summary>
            InBuffer - Unused.
            OutBuffer - EXCEPTION_RECORD64.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_WIN32_MAJOR_MINOR_VERSIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG[2] major/minor.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_USER_MINIDUMP_STREAM">
            <summary>
            InBuffer - DEBUG_READ_USER_MINIDUMP_STREAM.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_CAN_DETACH">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_LOCAL_IMPLICIT_COMMAND_LINE">
            <summary>
            InBuffer - PTSTR.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CAPTURED_EVENT_CODE_OFFSET">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream offset.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_CAPTURED_EVENT_CODE_STREAM">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.EXT_TYPED_DATA_ANSI">
            <summary>
            InBuffer - Input data block.
            OutBuffer - Processed data block.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_EXTENSION_SEARCH_PATH_WIDE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Returned path.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_WIDE">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - DEBUG_CACHED_SYMBOL_INFO.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.ADD_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - DEBUG_CACHED_SYMBOL_INFO.
            OutBuffer - ULONG64 cookie.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.REMOVE_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_ANSI">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_OFFSET_UNWIND_INFORMATION">
            <summary>
            InBuffer - ULONG64 offset.
            OutBuffer - Unwind information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_DUMP_HEADER">
            <summary>
            InBuffer - Unused
            OutBuffer - returned DUMP_HEADER32/DUMP_HEADER64 structure.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_DUMP_HEADER">
            <summary>
            InBuffer - DUMP_HEADER32/DUMP_HEADER64 structure.
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MIDORI">
            <summary>
            InBuffer - Midori specific
            OutBuffer - Midori specific
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.PROCESS_DESCRIPTORS">
            <summary>
            InBuffer - Unused
            OutBuffer - PROCESS_NAME_ENTRY blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MISC_INFORMATION">
            <summary>
            InBuffer - Unused
            OutBuffer - MINIDUMP_MISC_INFO_N blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_PROCESS_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_THREAD_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.DUPLICATE_TOKEN">
            <summary>
            InBuffer -  ULONG64 as TokenHandle being duplicated
            OutBuffer - ULONG64 as new duplicated TokenHandle
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.QUERY_INFO_TOKEN">
            <summary>
            InBuffer - a ULONG64 as TokenHandle and a ULONG as NtQueryInformationToken() request code
            OutBuffer - NtQueryInformationToken() return
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CLOSE_TOKEN">
            <summary>
            InBuffer - ULONG64 as TokenHandle
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_PROCESS">
            <summary>
            InBuffer - ULONG64 for process server identification and ULONG as PID
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_MODULE">
            <summary>
            InBuffer - ULONG64 for process server identification and PWSTR as module path
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.LIVE_USER_NON_INVASIVE">
            <summary>
            InBuffer - Unused
            OutBuffer - Unused
            return - S_OK if non-invasive user-mode attach, S_FALSE if not (but still live user-mode), E_FAIL otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.RESUME_THREAD">
            <summary>
            InBuffer - TID
            OutBuffer - Unused
            return - ResumeThreads() return.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.INSIDE_WAIT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status is changing due to operations performed during a
               wait, such as making synchronous callbacks. If the bit is not set the
               execution status is changing due to a wait being satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.WAIT_TIMEOUT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status update is coming after a wait has timed-out. It
               indicates that the execution status change was not due to an actual event.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.New">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.CreateAlways">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenExisting">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenAlways">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.TruncateExisting">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interop.IDebugOutputCallbacks2.Output(Microsoft.Diagnostics.Runtime.Interop.DEBUG_OUTPUT,System.String)">
            <summary>
               This method is not used.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID">
            <summary>
               Describes a symbol within a module.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.ModuleBase">
            <summary>
               The location in the target's virtual address space of the module's base address.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.Id">
            <summary>
               The symbol ID of the symbol within the module.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComInterfaceData">
            <summary>
            The COM implementation details of a single CCW entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.Type">
            <summary>
            The CLR type this represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.InterfacePointer">
            <summary>
            The interface pointer of Type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CcwData">
            <summary>
            Helper for Com Callable Wrapper objects.  (CCWs are CLR objects exposed to native code as COM
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Object">
            <summary>
            Returns the pointer to the managed object representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Handle">
            <summary>
            Returns the CLR handle associated with this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.RefCount">
            <summary>
            Returns the refcount of this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Interfaces">
            <summary>
            Returns the interfaces that this CCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RcwData">
            <summary>
            Helper for Runtime Callable Wrapper objects.  (RCWs are COM objects which are exposed to the runtime
            as managed objects.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.VTablePointer">
            <summary>
            Returns the external VTable associated with this RCW.  (It's useful to resolve the VTable as a symbol
            which will tell you what the underlying native type is...if you have the symbols for it loaded).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.RefCount">
            <summary>
            Returns the RefCount of the RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Object">
            <summary>
            Returns the managed object associated with this of RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Disconnected">
            <summary>
            Returns true if the RCW is disconnected from the underlying COM type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.CreatorThread">
            <summary>
            Returns the thread which created this RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.WinRTObject">
            <summary>
            Returns the internal WinRT object associated with this RCW (if one exists).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Interfaces">
            <summary>
            Returns the list of interfaces this RCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrAppDomain">
            <summary>
            Represents an AppDomain in the target runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules">
            <summary>
            Returns a list of modules loaded into this AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile">
            <summary>
            Returns the config file used for the AppDomain.  This may be null if there was no config file
            loaded, or if the targeted runtime does not support enumerating that data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.AppBase">
            <summary>
            Returns the base directory for this AppDomain.  This may return null if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStaticField">
            <summary>
            Represents a static field in the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrField">
            <summary>
            A representation of a field in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsPrimitive">
            <summary>
            Returns true if this field is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this field is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsValueClass">
            <summary>
            Returns true if this field is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this field is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsObjectReference">
            <summary>
            Returns true if this field is an object reference, false otherwise.
            </summary>
            <returns>True if this field is an object reference, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Name">
            <summary>
            The name of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Type">
            <summary>
            The type of the field.  Note this property may return null on error.  There is a bug in several versions
            of our debugging layer which causes this.  You should always null-check the return value of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ElementType">
            <summary>
            Returns the element type of this field.  Note that even when Type is null, this should still tell you
            the element type of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Size">
            <summary>
            Gets the size of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPublic">
            <summary>
            Returns true if this field is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrivate">
            <summary>
            Returns true if this field is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsInternal">
            <summary>
            Returns true if this field is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsProtected">
            <summary>
            Returns true if this field is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.HasSimpleValue">
            <summary>
            Returns true if this field has a simple value (meaning you may call "GetFieldValue" in one of the subtypes
            of this class).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Gets the value of the static field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the value.</param>
            <returns>The value of this static field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns the address of the static field's value in memory.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetDefaultValue">
            <summary>
            The default value of the field.
            </summary>
            <returns>The default value of the field.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStaticField.HasDefaultValue">
            <summary>
            Returns true if the static field has a default value (and if we can obtain it).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadStaticField">
            <summary>
            Represents a thread static value in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the value of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's value.</param>
            <param name="thread">The thread on which to get the field's value.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the address of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <param name="thread">The thread on which to get the field's address.</param>
            <returns>The address of the field.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInstanceField">
            <summary>
            Represents an instance field of a type.   Fundamentally it respresents a name and a type 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64)">
            <summary>
            Returns the value of this field.  Equivalent to GetFieldValue(objRef, false).
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64,System.Boolean)">
            <summary>
            Returns the value of this field, optionally specifying if this field is
            on a value class which is on the interior of another object.
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64,System.Boolean)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHeap">
            <summary>
            A ClrHeap is a abstraction for the whole GC Heap.   Subclasses allow you to implement this for 
            a particular kind of heap (whether live,
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectType(System.UInt64)">
            <summary>
            And the ability to take an address of an object and fetch its type (The type alows further exploration)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetExceptionObject(System.UInt64)">
            <summary>
            Returns a  wrapper around a System.Exception object (or one of its subclasses).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetRuntime">
            <summary>
            Returns the runtime associated with this heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots">
            <summary>
            Enumerate the roots of the process.  (That is, all objects which keep other objects alive.)
            Equivalent to EnumerateRoots(true).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByIndex(System.Int32)">
            <summary>
            Returns a type by its index.
            </summary>
            <param name="index">The type to get.</param>
            <returns>The ClrType of that index.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots(System.Boolean)">
            <summary>
            Enumerate the roots in the process.
            </summary>
            <param name="enumerateStatics">True if we should enumerate static variables.  Enumerating with statics 
            can take much longer than enumerating without them.  Additionally these will be be "double reported",
            since all static variables are pinned by handles on the HandleTable (which is also enumerated with 
            EnumerateRoots).  You would want to enumerate statics with roots if you care about what exact statics
            root what objects, but not if you care about performance.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateTypes">
            <summary>
            Enumerates all types in the runtime.
            </summary>
            <returns>An enumeration of all types in the target process.  May return null if it's unsupported for
            that version of CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjects">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateBlockingObjects">
            <summary>
            Enumerates all managed locks in the process.  That is anything using System.Monitor either explictly
            or implicitly through "lock (obj)".  This is roughly equivalent to combining SOS's !syncblk command
            with !dumpheap -thinlock.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects">
            <summary>
            Enumerates all objects on the heap.  This is equivalent to enumerating all segments then walking
            each object with ClrSegment.FirstObject, ClrSegment.NextObject, but in a simple enumerator
            for easier use in linq queries.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSizeByGen(System.Int32)">
            <summary>
            Get the size by generation 0, 1, 2, 3.  The large object heap is Gen 3 here. 
            The sum of all of these should add up to the TotalHeapSize.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSegmentByAddress(System.UInt64)">
            <summary>
            Returns the GC segment for the given object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.IsInHeap(System.UInt64)">
            <summary>
            Returns true if the given address resides somewhere on the managed heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ToString">
            <summary>
            Returns a string representation of this heap, including the size and number of segments.
            </summary>
            <returns>The string representation of this heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 'count' bytes from the ClrHeap at 'address' placing it in 'buffer' starting at offset 'offset'
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Segments">
            <summary>
            A heap is has a list of contiguous memory regions called segments.  This list is returned in order of
            of increasing object addresses.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TypeIndexLimit">
            <summary>
            Returns the max index.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.CanWalkHeap">
            <summary>
            Returns true if the GC heap is in a consistent state for heap enumeration.  This will return false
            if the process was stopped in the middle of a GC, which can cause the GC heap to be unwalkable.
            Note, you may still attempt to walk the heap if this function returns false, but you will likely
            only be able to partially walk each segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TotalHeapSize">
            <summary>
            TotalHeapSize is defined as the sum of the length of all segments.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.PointerSize">
            <summary>
            Pointer size of on the machine (4 or 8 bytes).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRoot">
            <summary>
            Represents a root in the target process.  A root is the base entry to the GC's mark and sweep algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRoot.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Kind">
            <summary>
            A GC Root also has a Kind, which says if it is a strong or weak root
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Name">
            <summary>
            The name of the root. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Type">
            <summary>
            The type of the object this root points to.  That is, ClrHeap.GetObjectType(ClrRoot.Object).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Object">
            <summary>
            The object on the GC heap that this root keeps alive.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Address">
            <summary>
            The address of the root in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.AppDomain">
            <summary>
            If the root can be identified as belonging to a particular AppDomain this is that AppDomain.
            It an be null if there is no AppDomain associated with the root.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Thread">
            <summary>
            If the root has a thread associated with it, this will return that thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsInterior">
            <summary>
            Returns true if Object is an "interior" pointer.  This means that the pointer may actually
            point inside an object instead of to the start of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPinned">
            <summary>
            Returns true if the root "pins" the object, preventing the GC from relocating it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPossibleFalsePositive">
            <summary>
            Unfortunately some versions of the APIs we consume do not give us perfect information.  If
            this property is true it means we used a heuristic to find the value, and it might not
            actually be considered a root by the GC.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingObject">
            <summary>
            Represents a managed lock within the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Object">
            <summary>
            The object associated with the lock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Taken">
            <summary>
            Whether or not the object is currently locked.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.RecursionCount">
            <summary>
            The recursion count of the lock (only valid if Locked is true).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owner">
            <summary>
            The thread which currently owns the lock.  This is only valid if Taken is true and
            only valid if HasSingleOwner is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.HasSingleOwner">
            <summary>
            Returns true if this lock has only one owner.  Returns false if this lock
            may have multiple owners (for example, readers on a RW lock).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owners">
            <summary>
            Returns the list of owners for this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Waiters">
            <summary>
            Returns the list of threads waiting on this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Reason">
            <summary>
            The reason why it's blocking.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrException">
            <summary>
            A wrapper class for exception objects which help with common tasks for exception objects.
            Create this using GCHeap.GetExceptionObject.  You may call that when GCHeapType.IsException
            returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Type">
            <summary>
            Returns the GCHeapType for this exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Message">
            <summary>
            Returns the exception message.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Address">
            <summary>
            Returns the address of the exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Inner">
            <summary>
            Returns the inner exception, if one exists, null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.HResult">
            <summary>
            Returns the HRESULT associated with this exception (or S_OK if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.StackTrace">
            <summary>
            Returns the StackTrace for this exception.  Note that this may be empty or partial depending
            on the state of the exception in the process.  (It may have never been thrown or we may be in
            the middle of constructing the stackwalk.)  This returns an empty list if no stack trace is
            associated with this exception object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime">
            <summary>
            Represents a single runtime in a target process or crash dump.  This serves as the primary
            entry point for getting diagnostic information.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateGCThreads">
            <summary>
            Enumerates the OS thread ID of GC threads in the runtime.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateFinalizerQueue">
            <summary>
            Enumerates all objects currently on the finalizer queue.  (Not finalizable objects, but objects
            which have been collected and will be imminently finalized.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadVirtual(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read data out of the target process.
            </summary>
            <param name="address">The address to start the read from.</param>
            <param name="buffer">The buffer to write memory to.</param>
            <param name="bytesRequested">How many bytes to read (must be less than/equal to buffer.Length)</param>
            <param name="bytesRead">The number of bytes actually read out of the process.  This will be less than
            bytes requested if the request falls off the end of an allocation.</param>
            <returns>False if the memory is not readable (free or no read permission), true if *some* memory was read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Reads a pointer value out of the target process.  This function reads only the target's pointer size,
            so if this is used on an x86 target, only 4 bytes is read and written to val.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="value">The value at that address.</param>
            <returns>True if the read was successful, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateHandles">
            <summary>
            Enumerates a list of GC handles currently in the process.  Note that this list may be incomplete
            depending on the state of the process when we attempt to walk the handle table.
            </summary>
            <returns>The list of GC handles in the process, NULL on catastrophic error.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetThreadPool">
            <summary>
            Returns data on the CLR thread pool for this runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByAddress(System.UInt64)">
            <summary>
            Attempts to get a ClrMethod for the given instruction pointer.  This will return NULL if the
            given instruction pointer is not within any managed method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateModules">
            <summary>
            Enumerates all modules in the process.
            </summary>
            <returns>An enumeration of modules.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ServerGC">
            <summary>
            Whether or not the process is running in server GC mode or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.HeapCount">
            <summary>
            The number of logical GC heaps in the process.  This is always 1 for a workstation
            GC, and usually it's the number of logical processors in a server GC application.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.AppDomains">
            <summary>
            Enumerates the list of appdomains in the process.  Note the System appdomain and Shared
            AppDomain are omitted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetAppDomainByAddress(System.UInt64)">
            <summary>
            Converts an address into an AppDomain.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetTypeName(Microsoft.Diagnostics.Runtime.Desktop.TypeHandle)">
            <summary>
            
            Returns the name of the type as specified by the TypeHandle.  Note this returns the name as specified by the
            metadata, NOT as you would expect to see it in a C# program.  For example, generics are denoted with a ` and
            the number of params.  Thus a Dictionary (with two type params) would look like:
                System.Collections.Generics.Dictionary`2
            </summary>
            <param name="id">The TypeHandle to get the name of.</param>
            <returns>The name of the type, or null on error.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.CLRVersion">
            <summary>
            Returns the version of the target process (v2, v4, v45)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.ArrayMethodTable">
            <summary>
            Returns the MethodTable for an array of objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.StringMethodTable">
            <summary>
            Returns the MethodTable for string objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.FreeMethodTable">
            <summary>
            Returns the MethodTable for free space markers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SystemDomainAddress">
            <summary>
            The address of the system domain in CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SharedDomainAddress">
            <summary>
            The address of the shared domain in CLR.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMethod">
            <summary>
            Represents a method on a class.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetFullSignature">
            <summary>
            Returns the full signature of the function.  For example, "void System.Foo.Bar(object o, int i)"
            would return "System.Foo.Bar(System.Object, System.Int32)"
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Name">
            <summary>
            The name of the method.  For example, "void System.Foo.Bar(object o, int i)" would return "Bar".
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.NativeCode">
            <summary>
            Returns the instruction pointer in the target process for the start of the method's assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.CompilationType">
            <summary>
            Returns the way this method was compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.ILOffsetMap">
            <summary>
            Returns the IL to native offset mapping.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MetadataToken">
            <summary>
            Returns the metadata token of the current method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Type">
            <summary>
            Returns the enclosing type of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPublic">
            <summary>
            Returns if this method is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPrivate">
            <summary>
            Returns if this method is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsInternal">
            <summary>
            Returns if this method is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsProtected">
            <summary>
            Returns if this method is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsStatic">
            <summary>
            Returns if this method is static.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsFinal">
            <summary>
            Returns if this method is final.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPInvoke">
            <summary>
            Returns if this method is a PInvoke.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsSpecialName">
            <summary>
            Returns if this method is a special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsRTSpecialName">
            <summary>
            Returns if this method is runtime special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsVirtual">
            <summary>
            Returns if this method is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsAbstract">
            <summary>
            Returns if this method is abstract.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrModule">
            <summary>
            Represents a managed module in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypes">
            <summary>
            Enumerate all types defined by this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)">
            <summary>
            Attempts to obtain a ClrType based on the name of the type.  Note this is a "best effort" due to
            the way that the dac handles types.  This function will fail for Generics, and types which have
            never been constructed in the target process.  Please be sure to null-check the return value of
            this function.
            </summary>
            <param name="name">The name of the type.  (This would be the EXACT value returned by ClrType.Name.</param>
            <returns>The requested ClrType, or null if the type doesn't exist or couldn't be constructed.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName">
            <summary>
            Returns the name of the assembly that this module is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Name">
            <summary>
            Returns the name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic">
            <summary>
            Returns true if this module was created through Reflection.Emit (and thus has no associated
            file).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsFile">
            <summary>
            Returns true if this module is an actual PEFile on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.FileName">
            <summary>
            Returns the filename of where the module was loaded from on disk.  Undefined results if
            IsPEFile returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase">
            <summary>
            Returns the base of the image loaded into memory.  This may be 0 if there is not a physical
            file backing it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Size">
            <summary>
            Returns the size of the image in memory.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress">
            <summary>
            The location of metadata for this module in the process's memory.  This is useful if you
            need to manually create IMetaData* objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength">
            <summary>
            The length of the metadata for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataImport">
            <summary>
            The IMetaDataImport interface for this module.  Note that this API does not provide a
            wrapper for IMetaDataImport.  You will need to wrap the API yourself if you need to use this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode">
            <summary>
            The debugging attributes for this module.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegion">
            <summary>
            Represents a region of memory in the process which Clr allocated and controls.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString(System.Boolean)">
            <summary>
            Returns a string describing the region of memory (for example "JIT Code Heap"
            or "GC Segment").
            </summary>
            <param name="detailed">Whether or not to include additional data such as the module,
            AppDomain, or GC Heap associated with it.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Address">
            <summary>
            The start address of the memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Size">
            <summary>
            The size of the memory region in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Type">
            <summary>
            The type of heap/memory that the region contains.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.AppDomain">
            <summary>
            The AppDomain pointer that corresponds to this heap.  You can obtain the
            name of the AppDomain index or name by calling the appropriate function
            on RuntimeBase.
            Note:  HasAppDomainData must be true before getting this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Module">
            <summary>
            The Module pointer that corresponds to this heap.  You can obtain the
            filename of the module with this property.
            Note:  HasModuleData must be true or this property will be null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.HeapNumber">
            <summary>
            Returns the heap number associated with this data.  Returns -1 if no
            GC heap is associated with this memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.GCSegmentType">
            <summary>
            Returns the gc segment type associated with this data.  Only callable if
            HasGCHeapData is true.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.MemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.AllocPointers">
            <summary>
            The allocation context pointers/limits for this heap.  The keys of this
            dictionary are the allocation pointers, the values of this dictionary are
            the limits.  If an allocation pointer is ever reached while walking a
            segment, you must "skip" past the allocation limit.  That is:
                if (curr_obj is in AllocPointers)
                    curr_obj = AllocPointers[curr_obj] + min_object_size;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralSegment">
            <summary>
            Returns the address of the ephemeral segment.  Users of this API should use
            HeapSegment.Ephemeral instead of this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralEnd">
            <summary>
            Returns the actual end of the ephemeral segment.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadPool">
            <summary>
            Provides information about CLR's threadpool.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateNativeWorkItems">
            <summary>
            Enumerates the work items on the threadpool (native side).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateManagedWorkItems">
            <summary>
            Enumerates work items on the thread pool (managed side).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.TotalThreads">
            <summary>
            The total number of threadpool worker threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.RunningThreads">
            <summary>
            The number of running threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.IdleThreads">
            <summary>
            The number of idle threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinThreads">
            <summary>
            The minimum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxThreads">
            <summary>
            The maximum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinCompletionPorts">
            <summary>
            Returns the minimum number of completion ports (if any).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxCompletionPorts">
            <summary>
            Returns the maximum number of completion ports.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.CpuUtilization">
            <summary>
            Returns the CPU utilization of the threadpool (as a percentage out of 100).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.FreeCompletionPortCount">
            <summary>
            The number of free completion port threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxFreeCompletionPorts">
            <summary>
            The maximum number of free completion port threads.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ManagedWorkItem">
            <summary>
            A managed threadpool object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Object">
            <summary>
            The object address of this entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Type">
            <summary>
            The type of Object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.NativeWorkItem">
            <summary>
            Represents a work item on CLR's thread pool (native side).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Kind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Callback">
            <summary>
            Returns the callback's address.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Data">
            <summary>
            Returns the pointer to the user's data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrame">
            <summary>
            A frame in a managed stack trace.  Note you can call ToString on an instance of this object to get the
            function name (or clr!Frame name) similar to SOS's !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.InstructionPointer">
            <summary>
            The instruction pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.StackPointer">
            <summary>
            The stack pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind">
            <summary>
            The type of frame (managed or internal).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.DisplayString">
            <summary>
            The string to display in a stack trace.  Similar to !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Method">
            <summary>
            Returns the ClrMethod which corresponds to the current stack frame.  This may be null if the
            current frame is actually a CLR "Internal Frame" representing a marker on the stack, and that
            stack marker does not have a managed method associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThread">
            <summary>
            Represents a managed thread in the target process.  Note this does not wrap purely native threads
            in the target process (that is, threads which have never run managed code before).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackObjects">
            <summary>
            Enumerates the GC references (objects) on the stack.
            </summary>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsFinalizer">
            <summary>
            Returns true if this is the finalizer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Address">
            <summary>
            The address of the underlying datastructure which makes up the Thread object.  This
            serves as a unique identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAlive">
            <summary>
            Returns true if the thread is alive in the process, false if this thread was recently terminated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.OSThreadId">
            <summary>
            The OS thread id for the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.ManagedThreadId">
            <summary>
            The managed thread ID (this is equivalent to System.Threading.Thread.ManagedThreadId
            in the target process).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.AppDomain">
            <summary>
            The AppDomain the thread is running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.LockCount">
            <summary>
            The number of managed locks (Monitors) the thread has currently entered but not left.
            This will be highly inconsistent unless the process is stopped.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Teb">
            <summary>
            The TEB (thread execution block) address in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackBase">
            <summary>
            The base of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackLimit">
            <summary>
            The limit of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackTrace">
            <summary>
            Returns the managed stack trace of the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentException">
            <summary>
            Returns the exception currently on the thread.  Note that this field may be null.  Also note
            that this is basically the "last thrown exception", and may be stale...meaning the thread could
            be done processing the exception but a crash dump was taken before the current exception was
            cleared off the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGC">
            <summary>
            Returns if this thread is a GC thread.  If the runtime is using a server GC, then there will be
            dedicated GC threads, which this will indicate.  For a runtime using the workstation GC, this flag
            will only be true for a thread which is currently running a GC (and the background GC thread).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebuggerHelper">
            <summary>
            Returns if this thread is the debugger helper thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolTimer">
            <summary>
            Returns true if this thread is a threadpool timer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolCompletionPort">
            <summary>
            Returns true if this thread is a threadpool IO completion port.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWorker">
            <summary>
            Returns true if this is a threadpool worker thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWait">
            <summary>
            Returns true if this is a threadpool wait thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolGate">
            <summary>
            Returns true if this is the threadpool gate thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSuspendingEE">
            <summary>
            Returns if this thread currently suspending the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsShutdownHelper">
            <summary>
            Returns true if this thread is currently the thread shutting down the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAbortRequested">
            <summary>
            Returns true if an abort was requested for this thread (such as Thread.Abort, or AppDomain unload).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAborted">
            <summary>
            Returns true if this thread was aborted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGCSuspendPending">
            <summary>
            Returns true if the GC is attempting to suspend this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUserSuspended">
            <summary>
            Returns true if the user has suspended the thread (using Thread.Suspend).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebugSuspended">
            <summary>
            Returns true if the debugger has suspended the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsBackground">
            <summary>
            Returns true if this thread is a background thread.  (That is, if the thread does not keep the
            managed execution environment alive and running.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUnstarted">
            <summary>
            Returns true if this thread was created, but not started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsCoInitialized">
            <summary>
            Returns true if the Clr runtime called CoIntialize for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSTA">
            <summary>
            Returns true if this thread is in a COM single threaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsMTA">
            <summary>
            Returns true if the thread is a COM multithreaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.BlockingObjects">
            <summary>
            Returns the object this thread is blocked waiting on, or null if the thread is not blocked.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInterface">
            <summary>
            An interface implementation in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.Name">
            <summary>
            The typename of the interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.BaseInterface">
            <summary>
            The interface that this interface inherits from.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrType">
            <summary>
            A representation of a type in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetSize(System.UInt64)">
            <summary>
            GetSize returns the size in bytes for the total overhead of the object 'objRef'.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateRefsOfObject(System.UInt64,System.Action{System.UInt64,System.Int32})">
            <summary>
            EnumeationRefsOfObject will call 'action' once for each object reference inside 'objRef'.  
            'action' is passed the address of the outgoing refernece as well as an integer that
            represents the field offset.  While often this is the physical offset of the outgoing
            refernece, abstractly is simply something that can be given to GetFieldForOffset to 
            return the field information for that object reference  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizeSuppressed(System.UInt64)">
            <summary>
            Returns true if the finalization is suppressed for an object.  (The user program called
            System.GC.SupressFinalize.  The behavior of this function is undefined if the object itself
            is not finalizable.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldForOffset(System.Int32,System.Boolean,Microsoft.Diagnostics.Runtime.ClrInstanceField@,System.Int32@)">
            <summary>
            When you enumerate a object, the offset within the object is returned.  This offset might represent
            nested fields (obj.Field1.Field2).    GetFieldOffset returns the first of these field (Field1), 
            and 'remaining' offset with the type of Field1 (which must be a struct type).   Calling 
            GetFieldForOffset repeatedly until the childFieldOffset is 0 will retrieve the whole chain.  
            </summary>
            <returns>true if successful.  Will fail if it 'this' is an array type</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetStaticFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Convenience function which dereferences fields.  For example, if you wish to dereference m_foo.m_bar.m_baz, you can pass:
            { "m_foo", "m_bar", "m_baz" } into this function's second parameter to dereference those fields to get the value.
            Throws Exception if a field you expect does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String},System.Object@)">
            <summary>
            Same as GetFieldValue but returns true on success, false on failure, and does not throw.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsCCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Com-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetCCWData(System.UInt64)">
            <summary>
            Returns the CCWData for the given object.  Note you may only call this function if IsCCW returns true.
            </summary>
            <returns>The CCWData associated with the object, undefined result of obj is not a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsRCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Runtime-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is an RCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetRCWData(System.UInt64)">
            <summary>
            Returns the RCWData for the given object.  Note you may only call this function if IsRCW returns true.
            </summary>
            <returns>The RCWData associated with the object, undefined result of obj is not a RCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayLength(System.UInt64)">
            <summary>
            If the type is an array, then GetArrayLength returns the number of elements in the array.  Undefined
            behavior if this type is not an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementAddress(System.UInt64,System.Int32)">
            <summary>
            Returns the absolute address to the given array element.  You may then make a direct memory read out
            of the process to get the value if you want.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementValue(System.UInt64,System.Int32)">
            <summary>
            Returns the array element value at the given index.  Returns 'null' if the array element is of type
            VALUE_CLASS.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumElementType">
            <summary>
            Returns the element type of this enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumNames">
            <summary>
            Returns a list of names in the enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetEnumValue(System.String,System.Int32@)">
            <summary>
            Attempts to get the integer value for a given enum entry.  Note you should only call this function if
            GetEnumElementType returns ELEMENT_TYPE_I4.
            </summary>
            <param name="name">The name of the value to get (taken from GetEnumNames).</param>
            <param name="value">The value to write out.</param>
            <returns>True if we successfully filled value, false if 'name' is not a part of the enumeration.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetValue(System.UInt64)">
            <summary>
            Returns the simple value of an instance of this type.  Undefined behavior if HasSimpleValue returns false.
            For example ELEMENT_TYPE_I4 is an "int" and the return value of this function would be an int.
            </summary>
            <param name="address">The address of an instance of this type.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Index">
            <summary>
            The index of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Name">
            <summary>
            Types have names.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers">
            <summary>
            Returns true if the type CAN contain references to other objects.  This is used in optimizations 
            and 'true' can always be returned safely.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Heap">
            <summary>
            All types know the heap they belong to.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Module">
            <summary>
            Returns the module this type is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementType">
            <summary>
            Returns the ElementType of this Type.  Can return ELEMENT_TYPE_VOID on error.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrimitive">
            <summary>
            Returns true if this type is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this type is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsValueClass">
            <summary>
            Returns true if this type is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this type is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsObjectReference">
            <summary>
            Returns true if this type is an object reference, false otherwise.
            </summary>
            <returns>True if this type is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Interfaces">
            <summary>
            Returns the list of interfaces this type implements.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizable">
            <summary>
            Returns whether objects of this type are finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPublic">
            <summary>
            Returns true if this type is marked Public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrivate">
            <summary>
            returns true if this type is marked Private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInternal">
            <summary>
            Returns true if this type is accessable only by items in its own assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsProtected">
            <summary>
            Returns true if this nested type is accessable only by subtypes of its outer type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsAbstract">
            <summary>
            Returns true if this class is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsSealed">
            <summary>
            Returns true if this class is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInterface">
            <summary>
            Returns true if this type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Fields">
            <summary>
            Returns all possible fields in this type.   It does not return dynamically typed fields.  
            Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticFields">
            <summary>
            Returns a list of static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ThreadStaticFields">
            <summary>
            Returns a list of thread static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Methods">
            <summary>
            Gets the list of methods this type implements.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseType">
            <summary>
            If this type inherits from another type, this is that type.  Can return null if it does not inherit (or is unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsArray">
            <summary>
            A type is an array if you can use the array operators below, Abstractly arrays are objects 
            that whose children are not statically known by just knowing the type.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ArrayComponentType">
            <summary>
            Gets the type of the elements in the array.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementSize">
            <summary>
            Returns the size of individual elements of an array.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseSize">
            <summary>
            Returns the base size of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsString">
            <summary>
            Returns true if this type is System.String.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFree">
            <summary>
            Returns true if this type represents free space on the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsException">
            <summary>
            Returns true if this type is an exception (that is, it derives from System.Exception).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum">
            <summary>
            Returns true if this type is an enum.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.HasSimpleValue">
            <summary>
            Returns true if instances of this type have a simple value.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopHeapType.FixGenericsWorker(System.String,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            A messy version with better performance that doesn't use regular expression.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSegment">
            <summary>
            A GCHeapSegment represents a contiguous region of memory that is devoted to the GC heap. 
            Segments.  It has a start and end and knows what heap it belongs to.   Segments can
            optional have regions for Gen 0, 1 and 2, and Large properties.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.NextObject(System.UInt64)">
            <summary>
            Given an object on the segment, return the 'next' object in the segment.  Returns
            0 when there are no more objects.   (Or enumeration is not possible)  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object in this segment.
            </summary>
            <param name="obj">An object in this segment.</param>
            <returns>The generation of the given object if that object lies in this segment.  The return
                     value is undefined if the object does not lie in this segment.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start">
            <summary>
            The start address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.End">
            <summary>
            The end address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length">
            <summary>
            The number of bytes in the segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Heap">
            <summary>
            The GC heap associated with this segment.  There's only one GCHeap per process, so this is
            only a convenience method to keep from having to pass the heap along with a segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ProcessorAffinity">
            <summary>
            The processor that this heap is affinitized with.  In a workstation GC, there is no processor
            affinity (and the return value of this property is undefined).  In a server GC each segment
            has a logical processor in the PC associated with it.  This property returns that logical
            processor number (starting at 0).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Reserved">
            <summary>
            The amount of memory reserved for the segment, but not committed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Committed">
            <summary>
            The amount of memory committed for the segment (this may be longer than Length).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.FirstObject">
            <summary>
            If it is possible to move from one object to the 'next' object in the segment. 
            Then FirstObject returns the first object in the heap (or null if it is not
            possible to walk the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Large">
            <summary>
            Returns true if this is a segment for the Large Object Heap.  False otherwise.
            Large objects (greater than 85,000 bytes in size), are stored in their own segments and
            only collected on full (gen 2) collections. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Ephemeral">
            <summary>
            Returns true if this segment is the ephemeral segment (meaning it contains gen0 and gen1
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Start">
            <summary>
            Ephemeral heap sements have geneation 0 and 1 in them.  Gen 1 is always above Gen 2 and
            Gen 0 is above Gen 1.  This property tell where Gen 0 start in memory.   Note that
            if this is not an Ephemeral segment, then this will return End (which makes Gen 0 empty
            for this segment)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Length">
            <summary>
            The length of the gen0 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Start">
            <summary>
            The start of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Length">
            <summary>
            The length of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Start">
            <summary>
            The start of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Length">
            <summary>
            The length of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Architecture">
            <summary>
            The architecture of a process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Unknown">
            <summary>
            Unknown.  Should never be exposed except in case of error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.X86">
            <summary>
            x86.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Amd64">
            <summary>
            x64
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Arm">
            <summary>
            ARM
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrElementType">
            <summary>
            This is a representation of the metadata element type.  These values
            directly correspond with Clr's CorElementType.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown">
            <summary>
            Not one of the other types.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Boolean">
            <summary>
            ELEMENT_TYPE_BOOLEAN
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Char">
            <summary>
            ELEMENT_TYPE_CHAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int8">
            <summary>
            ELEMENT_TYPE_I1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt8">
            <summary>
            ELEMENT_TYPE_U1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int16">
            <summary>
            ELEMENT_TYPE_I2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt16">
            <summary>
            ELEMENT_TYPE_U2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int32">
            <summary>
            ELEMENT_TYPE_I4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt32">
            <summary>
            ELEMENT_TYPE_U4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int64">
            <summary>
            ELEMENT_TYPE_I8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt64">
            <summary>
            ELEMENT_TYPE_U8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Float">
            <summary>
            ELEMENT_TYPE_R4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Double">
            <summary>
            ELEMENT_TYPE_R8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.String">
            <summary>
            ELEMENT_TYPE_STRING
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Pointer">
            <summary>
            ELEMENT_TYPE_PTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Struct">
            <summary>
            ELEMENT_TYPE_VALUETYPE
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Class">
            <summary>
            ELEMENT_TYPE_CLASS
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Array">
            <summary>
            ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeInt">
            <summary>
            ELEMENT_TYPE_I
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeUInt">
            <summary>
            ELEMENT_TYPE_U
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.FunctionPointer">
            <summary>
            ELEMENT_TYPE_FNPTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Object">
            <summary>
            ELEMENT_TYPE_OBJECT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.SZArray">
            <summary>
            ELEMENT_TYPE_SZARRAY
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRootKind">
            <summary>
            The type of GCRoot that a ClrRoot represnts.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.StaticVar">
            <summary>
            The root is a static variable.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.ThreadStaticVar">
            <summary>
            The root is a thread static.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.LocalVar">
            <summary>
            The root is a local variable (or compiler generated temporary variable).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Strong">
            <summary>
            The root is a strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Weak">
            <summary>
            The root is a weak handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Pinning">
            <summary>
            The root is a strong pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Finalizer">
            <summary>
            The root comes from the finalizer queue.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.AsyncPinning">
            <summary>
            The root is an async IO (strong) pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Max">
            <summary>
            The max value of this enum.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrameType">
            <summary>
            The type of frame the ClrStackFrame represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.ManagedMethod">
            <summary>
            Indicates this stack frame is a standard managed method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.Runtime">
            <summary>
            Indicates this stack frame is a special stack marker that the Clr runtime leaves on the stack.
            Note that the ClrStackFrame may still have a ClrMethod associated with the marker.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingReason">
            <summary>
            Every thread which is blocking on an object specifies why the object is waiting.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.None">
            <summary>
            Object is not locked.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Unknown">
            <summary>
            Not able to determine why the object is blocking.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Monitor">
            <summary>
            The thread is waiting for a Mutex or Semaphore (such as Monitor.Enter, lock(obj), etc).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.MonitorWait">
            <summary>
            The thread is waiting for a mutex with Monitor.Wait.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitOne">
            <summary>
            The thread is waiting for an event (ManualResetEvent.WaitOne, AutoResetEvent.WaitOne).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAll">
            <summary>
            The thread is waiting in WaitHandle.WaitAll.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAny">
            <summary>
            The thread is waiting in WaitHandle.WaitAny.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ThreadJoin">
            <summary>
            The thread is blocked on a call to Thread.Join.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ReaderAcquired">
            <summary>
            ReaderWriterLock, reader lock is taken.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WriterAcquired">
            <summary>
            ReaderWriterLock, writer lock is taken.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VersionInfo">
            <summary>
            Represents the version of a DLL.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Major">
            <summary>
            In a version 'A.B.C.D', this field represents 'A'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Minor">
            <summary>
            In a version 'A.B.C.D', this field represents 'B'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Revision">
            <summary>
            In a version 'A.B.C.D', this field represents 'C'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Patch">
            <summary>
            In a version 'A.B.C.D', this field represents 'D'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The A.B.C.D version prepended with 'v'.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfo">
            <summary>
            Represents information about a single Clr runtime in a process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryGetDacLocation">
            <summary>
            The location of the Dac on the local machine, if a matching Dac could be found.
            If this returns null it means that no matching Dac could be found, and you will
            need to make a symbol server request using DacInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>A version string for this Clr runtime.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Version">
            <summary>
            The version number of this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DacInfo">
            <summary>
            Returns module information about the Dac needed create a ClrRuntime instance for this runtime.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AttachFlag">
            <summary>
            Specifies how to attach to a live process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Invasive">
            <summary>
            Performs an invasive debugger attach.  Allows the consumer of this API to control the target
            process through normal IDebug function calls.  The process will be paused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.NonInvasive">
            <summary>
            Performs a non-invasive debugger attach.  The process will be paused by this attached (and
            for the duration of the attach) but the caller cannot control the target process.  This is
            useful when there's already a debugger attached to the process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Passive">
            <summary>
            Performs a "passive" attach, meaning no debugger is actually attached to the target process.
            The process is not paused, so queries for quickly changing data (such as the contents of the
            GC heap or callstacks) will be highly inconsistent unless the user pauses the process through
            other means.  Useful when attaching with ICorDebug (managed debugger), as you cannot use a
            non-invasive attach with ICorDebug.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleInfo">
            <summary>
            Provides information about loaded modules in a DataTarget
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageBase">
            <summary>
            The base address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileSize">
            <summary>
            The filesize of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.TimeStamp">
            <summary>
            The build timestamp of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileName">
            <summary>
            The filename of the module on disk.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataTarget">
            <summary>
            A crash dump or live process to read out of.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadCrashDump(System.String)">
            <summary>
            Creates a DataTarget from a crash dump.
            </summary>
            <param name="fileName">The crash dump's filename.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.SetSymbolPath(System.String)">
            <summary>
            Sets the symbol path for ClrMD.
            </summary>
            <param name="path">This should be in the format that Windbg/dbgeng expects with the '.sympath' command.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDebuggerInterface(System.Object)">
            <summary>
            Creates a data target from an existing IDebugClient interface.  If you created and attached
            a dbgeng based debugger to a process you may pass the IDebugClient RCW object to this function
            to create the DataTarget.
            </summary>
            <param name="debugClient">The dbgeng IDebugClient object.  We will query interface on this for IDebugClient.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32)">
            <summary>
            Invasively attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32,Microsoft.Diagnostics.Runtime.AttachFlag)">
            <summary>
            Attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <param name="attachFlag">The type of attach requested for the target process.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.ReadProcessMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads memory from the target.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="buffer">The buffer to store the data in.  Size must be greator or equal to
            bytesRequested.</param>
            <param name="bytesRequested">The amount of bytes to read from the target process.</param>
            <param name="bytesRead">The actual number of bytes read.</param>
            <returns>True if any bytes were read out of the process (including a partial read).  False
            if no bytes could be read from the address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.String)">
            <summary>
            Creates a runtime from the given Dac file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.Object)">
            <summary>
            Creates a runtime from a given IXClrDataProcess interface.  Used for debugger plugins.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.EnumerateModules">
            <summary>
            Enumerates information about the loaded modules in the process (both managed and unmanaged).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.Architecture">
            <summary>
            Returns the architecture of the target process or crash dump.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.ClrVersions">
            <summary>
            Returns the list of Clr versions loaded into the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.PointerSize">
            <summary>
            Returns the pointer size for the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DebuggerInterface">
            <summary>
            Returns the IDebugClient interface associated with this datatarget.  (Will return null if the
            user attached passively.)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.WorkItemKind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.Unknown">
            <summary>
            Unknown.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncTimer">
            <summary>
            Callback for an async timer.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncCallback">
            <summary>
            Async callback.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.QueueUserWorkItem">
            <summary>
            From ThreadPool.QueueUserWorkItem.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.TimerDelete">
            <summary>
            Timer delete callback.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HandleType">
            <summary>
            Types of Clr handles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakShort">
            <summary>
            Weak, short lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakLong">
            <summary>
            Weak, long lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Strong">
            <summary>
            Strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Pinned">
            <summary>
            Strong handle, prevents relocation of target object.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.RefCount">
            <summary>
            RefCounted handle (strong when the reference count is greater than 0).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Dependent">
            <summary>
            A weak handle which may keep its "secondary" object alive if the "target" object is also alive.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.AsyncPinned">
            <summary>
            A strong, pinned handle (keeps the target object from being relocated), used for async IO operations.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.SizedRef">
            <summary>
            Strong handle used internally for book keeping.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandle">
            <summary>
            Represents a Clr handle in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Address">
            <summary>
            The address of the handle itself.  That is, *Address == Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Object">
            <summary>
            The Object the handle roots.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Type">
            <summary>
            The the type of the Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Strong">
            <summary>
            Whether the handle is strong (roots the object) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.HandleType">
            <summary>
            Gets the type of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.RefCount">
            <summary>
            If this handle is a RefCount handle, this returns the reference count.
            RefCount handles with a RefCount > 0 are strong.
            NOTE: v2 CLR CANNOT determine the RefCount.  We always set the RefCount
                  to 1 in a v2 query since a strong RefCount handle is the common case.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentTarget">
            <summary>
            Set only if the handle type is a DependentHandle.  Dependent handles add
            an extra edge to the object graph.  Meaning, this.Object now roots the
            dependent target, but only if this.Object is alive itself.
            NOTE: CLRs prior to v4.5 cannot obtain the dependent target.  This field will
                  be 0 for any CLR prior to v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentType">
            <summary>
            The type of the dependent target, if non 0.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.AppDomain">
            <summary>
            The AppDomain the handle resides in.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType">
            <summary>
            Types of memory regions in a Clr process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LowFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HighFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.StubHeap">
            <summary>
            Data on the stub heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.IndcellHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LookupHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ResolveHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.DispatchHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.CacheEntryHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitHostCodeHeap">
            <summary>
            Heap for JIT code data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitLoaderCodeHeap">
            <summary>
            Heap for JIT loader data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleThunkHeap">
            <summary>
            Heap for module jump thunks.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleLookupTableHeap">
            <summary>
            Heap for module lookup tables.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.GCSegment">
            <summary>
            A segment on the GC heap (committed memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ReservedGCSegment">
            <summary>
            A segment on the GC heap (reserved, but not committed, memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HandleTableChunk">
            <summary>
            A portion of Clr's handle table.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCSegmentType">
            <summary>
            Types of GC segments.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Ephemeral">
            <summary>
            Ephemeral segments are the only segments to contain Gen0 and Gen1 objects.
            It may also contain Gen2 objects, but not always.  Objects are only allocated
            on the ephemeral segment.  There is one ephemeral segment per logical GC heap.
            It is important to not have too many pinned objects in the ephemeral segment,
            or you will run into a performance problem where the runtime runs too many GCs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Regular">
            <summary>
            Regular GC segments only contain Gen2 objects.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.LargeObject">
            <summary>
            The large object heap contains objects greater than a certain threshold.  Large
            object segments are never compacted.  Large objects are directly allocated
            onto LargeObject segments, and all large objects are considered gen2.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MethodCompilationType">
            <summary>
            The way a method was JIT'ed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.None">
            <summary>
            Method is not yet JITed and no NGEN image exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Jit">
            <summary>
            Method was JITed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Ngen">
            <summary>
            Method was NGEN'ed (pre-JITed).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILToNativeMap">
            <summary>
            A method's mapping from IL to native offsets.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.ILOffset">
            <summary>
            The IL offset for this entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.startAddress">
            <summary>
            The native start offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.endAddress">
            <summary>
            The native end offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException">
            <summary>
            Exception thrown by Microsoft.Diagnostics.Runtime unless there is a more appropriate
            exception subclass.
            </summary>
        </member>
    </members>
</doc>
